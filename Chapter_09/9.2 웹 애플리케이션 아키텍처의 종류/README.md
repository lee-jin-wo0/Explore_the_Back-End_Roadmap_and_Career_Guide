# 9.2 웹 애플리케이션 아키텍처의 종류

## 9.2.1 모놀리식 아키텍처

**모놀리식 아키텍처(Monolithic Architecture)** : 하나의 대규모 응용 프로그램으로 구성된 전통적인 소프트웨어 아키텍처.

가장 큰 특징은 아키텍처가 단일 애플리케이션으로 이뤄진다는 것임. 즉 모든 기능이 하나의 코드 안에 있다는 것을 뜻함.

<br />

3티어 아키텍처는 3개의 계층으로 구성.

:spiral_notepad: 3티어 아키텍처 계층

:small_blue_diamond: 표현 계층(Presentation tier) : 사용자와 직접 접촉하는 계층. 웹 애플리케이션의 사용자 인터페이스 요소가 이 계층에 포함.

:small_blue_diamond: 논리 계층(Logic tier) : 웹 애플리케이션의 비즈니스 로직이 실행되는 계층. 웹 브라우저로부터 사용자의 요청을 받아 처리하는 웹 애플리케이션 서버가 이 계층에 포함.

:small_blue_diamond: 데이터 계층(data tier) : 웹 애플리케이션의 데이터 저장소에 접근해 데이터를 불러오거나 저장하는 계층. 어느 데이터베이스에 접근해 데이터를 회수하고 저장할지 등의 데이터 접근 경로는 논리 계층에서 결정.

<br />

:spiral_notepad: 3 티어 아키텍처로 설계된 웹 애플리케이션의 동작 과정

:one: 사용자가 표현 계층을 통해 논리 계층에 특정 데이터를 요청. www.naver.com과 같은 URL을 입력해 웹 사이트에 접속하거나 특정 링크를 클릭하는 행위가 이에 해당.

:two: 논리 계층은 요청 받은 데이터가 무엇인지 파악하고 데이터 계층과 통신해 실제 데이터를 받아옴.

:three: 논리 계층은 받아온 데이터를 표현 계층에 응답으로 전송.

:four: 표현 계층은 응답 받은 데이터를 사용자가 볼 수 있도록 화면에 출력.

<br />

### 모놀리식 아키텍처의 단점

:small_blue_diamond: 높은 결합도 : 코드 내 모든 모듈이 서로 강하게 결합돼 있음. 따라서 한 모듈을 변경하면 전체 시스템에 영향을 미침.

:small_blue_diamond: 높은 복잡성 : 시스템의 크기가 커질수록 코드의 복잡도가 증가하며, 이는 웹 애플리케이션의 유지, 보수와 개발을 어렵게 만듬.

:small_blue_diamond: 단일 데이터베이스 : 하나의 데이터베이스를 사용해 모든 데이터를 처리. 이 경우 데이터베이스 스키마(데이터의 논리적인 저장 구조)를 변경하기가 어려움.

:small_blue_diamond: 전체 시스템의 중단 가능성 : 전체 시스템이 단일 프로세스 내에서 실행되므로 시스템의 어느 한 부분에 문제가 발생하면 전체 시스템이 중단될 가능성이 있으며, 이는 시스템의 신뢰성을 떨어뜨림.

:small_blue_diamond: 개발 프로세스의 복잡성 : 모든 개발자가 하나의 코드를 공유하기 때문에 코드에 변경 사항이 생기면 모든 개발자와 공유하고 테스트해야 하는데, 이는 개발 프로세스를 복잡하게 만듬.

<br />

## 9.2.2 마이크로서비스 아키텍처

**마이크로서비스 아키텍처(MSA, MicroService Architecture)**는 모놀리식 아키텍처와 달리 웹 애플리케이션을 여러 개의 작은 서비스 단위로 분해해 각각의 서비스를 독립적으로 개발, 배포, 운영하는 방식. 다시 말해 하나의 큰 웹 애플리케이션을 여러 개의 작은 웹 애플리케이션으로 분해해 설계하는 것.

<br />

클라이언트-서버-데이터베이스의 3티어 구조로 설계되는 모놀리식 아키텍처와 달리 마이크로서비스 아키텍처는 각각의 서비스에 서버와 데이터베이스를 따로 구축.

이러한 서비스 하나하나를 **마이크로서비스**라고 하며, 모든 마이크로서비스는 API 게이트웨이와 연결됨.

마이크로서비스 아키텍처의 경우 사용자가 요청한 데이터, 즉 어떤 서비스를 요청하는지를 API 게이트웨이가 파악하고 해당 마이크로서비스에 요청을 전달함.

<br />

마이크로 서비스 아키텍처는 각 서비스마다 독립된 시스템의 분산 구조임.

<br />

:spiral_notepad: 마이크로서비스 아키텍처의 장점

:small_blue_diamond: 관심사 분리 : 각 서비스가 한 가지 기능을 수행하도록 설계됐으므로 개발 및 유지, 보수가 쉽고 확장성과 유연성이 뛰어남. 서비스 단위로 관심사가 분리되기 때문.

:small_blue_diamond: 분산 데이터 관리 : 각 서비스는 자체 데이터베이스를 가지기 때문에 데이터의 무결성과 안정성이 보장됨. 또한 데이터베이스의 스키마 변경에도 매우 유연하게 대처할 수 있음.

:small_blue_diamond: 개발과 배포의 용이성 : 각 서비스를 독립적으로 개발해 배포할 수 있음. 각각의 마이크로 서비스는 서로의 동작에 아무런 영향을 주지 않음. 또한 모놀리식 아키텍처가 모든 서비스에 대해 동일한 기술 스택을 적용하는 것과 달리 마이크로서비스 아키텍처는 각 서비스마다 최선의 기술 스택을 선택할 수 있음.

:small_blue_diamond: 높은 탄력성 : 하나의 서비스에 장애가 발생하더라도 다른 서비스가 정상적으로 작동함.

<br />

마이크로서비스 아키텍처에서 가장 중요한 것은 하나의 웹 애플리케이션을 서비스 단위로 나눠 개발한다는 것임.

개발자 입장에서는 자신이 맡은 마이크로서비스가 제공해야 하는 비즈니스 로직에만 집중할 수 잇어 전체 서비스 품질이 향상됨. 또한 서비스 단위에서 고려해야 하는 외부 조건이 적기 때문에 개발 생산성이 향상됨.

<br />

## 9.2.3 서버리스 아키텍처

**서버리스 아키텍처(Serverless Architecture)** : 특정 서비스를 구현하기 위한 서버가 존재하지 않는 아키텍처. 이는 실제 서버가 존재하지 않는다는 의미가 아니라 개발자가 서버를 신경 쓰지 않아도 된다는 것을 의미.

<br />

### BaaS

**BaaS(Backend as a Service)** : 클라우드 서비스 제공 업체가 관리하는 백엔드 서비스

웹 애플리케이션 개발 시 요구되는 복잡한 백엔드의 기능을 개발자가 직접 구현하지 않고 클라우드 업체가 제공하는 서비스를 이용해 쉽게 구현 가능.

업체는 서버 개발에 필요한 데이터베이스, 인증, 스토리지, 메시징 등의 기능을 제공하고, 개발자는 이러한 서비스를 활용해 웹 애플리케이션을 구축하는 것.

대표적인 BaaS는 파이어베이스(Firebase), AWS 앱싱크(AWS Appsync), 애저 코스모스 DB(Azure Cosmos DB) 등이 있음.

<br />

개발자는 BaaS가 제공하는 API를 통해 서비스를 구현함으로써 BaaS를 이름 그대로 백엔드 서버처럼 사용할 수 있음.

백엔드 구축에 필요한 인프라, 즉 서버의 사양이나 개수, 네트워크 선정 등의 기술적인 부분을 지원받을 수 있음.

BaaS는 자체적인 백엔드 서버를 굳이 구축할 필요가 없거나 백엔드 서버 구축에 들이는 비용을 아껴야 하는 경우에 좋음.

단점으로는 BaaS로 구현할 수 있는 기능은 BaaS가 제공하는 API에 한정됨.

자체적으로 서버를 구축할 때와 비교해 제한적인 기능만 사용할 수 있어 기능 구현에 한계가 있음.

기존의 백엔드 서버에 작성했던 코드를 API를 사용한 코드로 대체해야 하기 때문에 코드 수정 및 유지, 보수로 인한 배포가 잦아 사용자에게 강제적인 업데이트를 강요할 수 있음.

<br />

### FaaS

**FaaS(Function as a Service)** : 개발 프로젝트를 여러 개의 함수로 쪼개(또는 하나의 함수로 만들기도 함) 매우 거대하고 분산된 클라우드 컴퓨팅 환경에 미리 준비해둔 함수를 등록하고, 이러한 함수가 실행되는 횟수와 실행된 시간만큼 비용을 내는 방식.

FaaS는 개발자가 사용할 기능을 함수 단위로 나눠 구현해 등록하고 클라우드가 이를 서비스하는 형태.

FaaS의 대표적인 서비스는 AWS 람다(AWS Lambda)임.

<br />

FaaS는 서버가 항상 켜져 있는(always-on) 상태로 매번 각각의 API 요청에 응답을 반환하는 것이 아니라, 사용자가 등록해둔 함수가 특정 요인에 의해 실행돼 해당 함수가 백엔드의 기능을 수행하게 됨. 결국 복잡한 백엔드 서버 코드를 구현하지 않ㄴ고 단순히 서비스에 필요한 함수의 코드 스크립트만 작성해 등록하게 됨.

<br />

FaaS는 이러한 구조 덕분에 함수가 호출된 만큼만 사용료가 발생하므로 비용이 많이 절약.

함수를 등록하는 클라우드 업체 측에서 인프라 장비에 대한 구성 작업을 모두 관리하기 때문에 개발자가 신경 쓸 필요가 없음.

단점으로는 모든 코드를 함수로 쪼개 작업하다 보니 함수에서 사용할 수 잇는 자원에 제한.